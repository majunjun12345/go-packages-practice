### 限流器

限流可以在 nginx 中实现，也可以在业务代码中实现

#### 为什么需要限流
1. 对外的 api
  突发流量(爬虫、刷单、热点事件)
2. 对内的 rpc
  一个服务A的接口可能被BCDE多个服务进行调用，在B服务发生突发流量时，直接把A服务给调用挂了，导致CDE服务也异常。 
  两种解决方案： 1、每个调用方采用线程池进行资源隔离 2、使用限流手段对每个服务调用方进行限流;

### 限流算法的实现
1. 计数器算法
一般限制一秒钟的请求数，比如限流qps为100，就是从第一个请求进来开始计时，在接下去的1s内，每来一个请求，就把计数加1，如果累加的数字达到了100，拒绝后续请求。等到1s结束后，把计数恢复成0，重新开始计数。go 中一般采用 atomic 事项；

弊端：如果在单位时间1s内的前10ms，通过了100个请求，那后面的990ms，请求都会被拒绝，我们把这种现象称为“突刺现象”;

2. 漏桶算法
不管请求有多少，处理请求的频次固定;

不管服务调用方多么不稳定，通过漏桶算法进行限流，每10毫秒处理一次请求。因为处理的速度是固定的，请求进来的速度是未知的，可能突然进来很多请求，没来得及处理的请求就先放在桶里，如果桶满了，丢弃新请求。

在算法实现方面，可以准备一个队列，用来保存请求，另外通过一个线程池定期从队列中获取请求并执行，可以一次性获取多个并发执行。

弊端：无法应对短时间的突发流量。

3. 令牌桶算法
**桶算法**能够限制请求调用的速率
**令牌桶算法**能够在限制调用的平均速率的同时还允许一定程度的突发调用。

在令牌桶算法中，存在一个桶，用来存放固定数量的令牌，并以一定的速率往桶中放令牌。
每次请求调用需要先获取令牌，只有拿到令牌，才有机会继续执行，要么选择选择等待可用的令牌、要么直接拒绝。

放令牌是持续不断进行的，如果达到上限，则丢弃令牌，所以桶中一直有大量的可用令牌，请求可以直接拿到令牌执行
比如设置 qps 为100，那么限流器初始化完成一秒后，桶中就有100个令牌了，这时服务还没完全启动好，等启动完成对外提供服务时，该限流器可以抵挡瞬时的100个请求。
所以只有桶中没有令牌时，请求才会进行等待，最后相当于以一定的速率执行。